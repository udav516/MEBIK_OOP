# Задача 1. "Покупка дома"

Итак, мы с вами узнали, почему при разработке современных программ использование объектно-ориентированного подхода
является обязательным условием. Также разобрались в понятиях Класс, Объект(Экземпляр), Атрибут, Свойство(Поле), Метод.
Далее посмотрели, какими эти самые атрибуты, свойства и методы бывают. А еще научились отличать Protected атрибуты от
Private и разобрались, как реализована модель уровней доступа к атрибутам непосредственно в Python. Теперь давайте
постараемся эти знания применить на практике.
Перед вами задача "Покупка дома". С помощью подхода ООП и средств Python в рамках данной задачи необходимо реализовать
следующую предметную структуру:
Классовая структура:

- Есть Человек, характеристиками которого являются:
- Имя
- Возраст
- Наличие денег
- Наличие собственного жилья
  Человек может:
- Предоставить информацию о себе
- Заработать деньги
- Купить дом
  Также же есть Дом, к свойствам которого относятся:
- Площадь
- Стоимость
- Для Дома можно:
- Применить скидку на покупку
  Также есть Небольшой Типовой Дом, обязательной площадью 40м2.
  Задание. Часть 1. Класс Human

1. Создайте класс Human.
2. Определите для него два статических поля: default_name и default_age.
3. Создайте метод __init__(), который помимо self принимает еще два параметра: name и age. Для этих параметров задайте
   значения по умолчанию, используя свойства default_name и default_age. В методе __init__() определите четыре свойства:
   Публичные - name и age. Приватные - money и house.
4. Реализуйте справочный метод info(), который будет выводить поля name, age, house и money.
5. Реализуйте справочный статический метод default_info(), который будет выводить статические поля default_name и
   default_age.
6. Реализуйте приватный метод make_deal(), который будет отвечать за техническую реализацию покупки дома: уменьшать
   количество денег на счету и присваивать ссылку на только что купленный дом. В качестве аргументов данный метод
   принимает объект дома и его цену.
7. Реализуйте метод earn_money(), увеличивающий значение свойства money.
8. Реализуйте метод buy_house(), который будет проверять, что у человека достаточно денег для покупки, и совершать
   сделку. Если денег слишком мало - нужно вывести предупреждение в консоль. Параметры метода: ссылка на дом и размер
   скидки
   Задание. Часть 2. Класс House
1. Создайте класс House
2. Создайте метод __init__() и определите внутри него два динамических свойства: _area и_price. Свои начальные значения
   они получают из параметров метода __init__()
3. Создайте метод final_price(), который принимает в качестве параметра размер скидки и возвращает цену с учетом данной
   скидки.
   Задание. Часть 3. Класс SmallHouse
1. Создайте класс SmallHouse, унаследовав его функционал от класса House
2. Внутри класса SmallHouse переопределите метод __init__() так, чтобы он создавал объект с площадью 40м2
   Задание. Часть 4. Тесты
1. Вызовите справочный метод default_info() для класса Human
2. Создайте объект класса Human
3. Выведите справочную информацию о созданном объекте (вызовите метод info()).
4. Создайте объект класса SmallHouse
5. Попробуйте купить созданный дом, убедитесь в получении предупреждения.
6. Поправьте финансовое положение объекта - вызовите метод earn_money()
7. Снова попробуйте купить дом
8. Посмотрите, как изменилось состояние объекта класса Human

# Задача 2. "Алфавит"

Алфавит. Классовая структура:
Есть Алфавит, характеристиками которого являются:

- Язык
- Список букв
  Для Алфавита можно:
- Напечатать все буквы алфавита
- Посчитать количество букв
  Так же есть Английский алфавит, который обладает следующими свойствами:
- Язык
- Список букв
- Количество букв
  Для Английского алфавита можно:
- Посчитать количество букв
- Определить, относится ли буква к английскому алфавиту
- Получить пример текста на английском языке
  Задание. Часть 1. Класс Alphabet

1. Создайте класс Alphabet
2. Создайте метод __init__(), внутри которого будут определены два динамических свойства: 1) lang - язык и 2) letters -
   список букв. Начальные значения свойств берутся из входных параметров метода.
3. Создайте метод print(), который выведет в консоль буквы алфавита
4. Создайте метод letters_num(), который вернет количество букв в алфавите
   Задание. Часть 2. Класс EngAlphabet
1. Создайте класс EngAlphabet путем наследования от класса Alphabet
2. Создайте метод __init__(), внутри которого будет вызываться родительский метод __init__(). В качестве параметров ему
   будут передаваться обозначение языка(например, 'En') и строка, состоящая из всех букв алфавита(можно воспользоваться
   свойством ascii_uppercase из модуля string).
3. Добавьте приватное статическое свойство __letters_num, которое будет хранить количество букв в алфавите.
4. Создайте метод is_en_letter(), который будет принимать букву в качестве параметра и определять, относится ли эта
   буква к английскому алфавиту.
5. Переопределите метод letters_num() - пусть в текущем классе классе он будет возвращать значение свойства __
   letters_num.
6. Создайте статический метод example(), который будет возвращать пример текста на английском языке.
   Задание. Часть 3. Тесты
1. Создайте объект класса EngAlphabet
2. Напечатайте буквы алфавита для этого объекта
3. Выведите количество букв в алфавите
4. Проверьте, относится ли буква F к английскому алфавиту
5. Проверьте, относится ли буква Щ к английскому алфавиту
6. Выведите пример текста на английском языке

# Задача 3. "Садовник и помидоры"

Классовая структура. Предлагаем создать следующую классовую структуру:
Есть Помидор со следующими характеристиками:

- Индекс
- Стадия зрелости (стадии: Отсутствует, Цветение, Зеленый, Красный)
  Помидор может:

1. Расти (переходить на следующую стадию созревания)
2. Предоставлять информацию о своей зрелости
   Есть Куст с помидорами, который:

- Содержит список томатов, которые на нем растут
  И может:
- Расти вместе с томатами
- Предоставлять информацию о зрелости всех томатов
- Предоставлять урожай
  И также есть Садовник, который имеет:
- Имя
- Растение, за которым он ухаживает
  И может:
- Ухаживать за растением
- Собирать с него урожай
  Задание. Часть 1. Класс Tomato

1. Создайте класс Tomato
2. Создайте статическое свойство states, которое будет содержать все стадии созревания помидора
3. Создайте метод __init__(), внутри которого будут определены два динамических protected свойства: 1) _index -
   передается параметром и 2)_state - принимает первое значение из словаря states
4. Создайте метод grow(), который будет переводить томат на следующую стадию созревания
5. Создайте метод is_ripe(), который будет проверять, что томат созрел (достиг последней стадии созревания)
   Задание. Часть 2. Класс TomatoBush
1. Создайте класс TomatoBush
2. Определите метод __init__(), который будет принимать в качестве параметра количество томатов и на его основе будет
   создавать список объектов класса Tomato. Данный список будет храниться внутри динамического свойства tomatoes.
3. Создайте метод grow_all(), который будет переводить все объекты из списка томатов на следующий этап созревания
4. Создайте метод all_are_ripe(), который будет возвращать True, если все томаты из списка стали спелыми
5. Создайте метод give_away_all(), который будет чистить список томатов после сбора урожая
   Задание. Часть 3. Класс Gardener
1. Создайте класс Gardener
2. Создайте метод __init__(), внутри которого будут определены два динамических свойства: 1) name - передается
   параметром, является публичным и 2) _plant - принимает объект класса TomatoBush, является protected
3. Создайте метод work(), который заставляет садовника работать, что позволяет растению становиться более зрелым
4. Создайте метод harvest(), который проверяет, все ли плоды созрели. Если все - садовник собирает урожай. Если нет -
   метод печатает предупреждение.
5. Создайте статический метод knowledge_base(), который выведет в консоль справку по садоводству.
   Задание. Часть 3. Тесты
1. Вызовите справку по садоводству
2. Создайте объекты классов TomatoBush и Gardener
3. Используя объект класса Gardener, поухаживайте за кустом с помидорами
4. Попробуйте собрать урожай
5. Если томаты еще не дозрели, продолжайте ухаживать за ними
6. Соберите урожай

# Задача 4. Класс Vector3D

Экземпляр класса задается тройкой координат в трехмерном пространстве (x,y,z). Обязательно должны быть реализованы
методы:

- сложение векторов оператором `+` (метод __add__),
- вычитание векторов оператором `-` (метод __sub__),
- скалярное произведение оператором `*` (метод __mul__),
- умножение на скаляр оператором `*` (метод __mul__),

# Задача 5. Класс «Прямоугольный треугольник»

Класс содержит два действительных числа – стороны треугольника. и включает
следующие методы:

- увеличение/уменьшение размера стороны на заданное количество процентов;
- вычисление радиуса описанной окружности,
- вычисление периметра,
- определение значений углов.

# Задача 6. Класс «Одномерный массив» TArray

Класс содержит поле для задания количества элементов и поле для хранения
элементов массива.
Методы:

- конструктор без параметров, конструктор с параметрами, конструктор копирования,
- ввод и вывод данных,
- поиск максимального и минимального элементов,
- сортировка массива,
- поиск суммы элементов
- перегрузка оператора + (добавление элемента)
- перегрузка оператора * умножение элементов массива на число

# Задача 7. Класс «Автобус»

Класс содержит свойства:

- speed (скорость),
- capacity (максимальное количество пассажиров),
- maxSpeed (максимальная скорость),
- passengers (список имен пассажиров),
- hasEmptySeats (наличие свободных мест),
- seats (словарь мест в автобусе);
  методы:
- посадка и высадка одного или нескольких пассажиров,
- увеличение и уменьшение скорости на заданное значение.
- операции "in", "+=" и "−=" (посадка и высадка пассажира(ов) с заданной фамилией)

# Задача 8. Класс «Снежинки» Snow

Класс содержит целое число - количество снежинок. Класс включает методы перегрузки арифметических операторов сложения,
вычитания, умножения и деления. Код этих методов должен выполнять увеличение или уменьшение количества снежинок на число
n или в n раз. Класс также включает метод makeSnow(), который принимает сам объект и число
снежинок в ряду, а возвращает строку вида
"*____\n____*\n*****…",
где количество снежинок между '\n' равно переданному аргументу, а количество рядов вычисляется, исходя из общего
количества снежинок.

# Задача 9. Класс «Снежинка» (SnowFlake)

При инициализации класс принимает целое нечетное число – сторону квадрата, в который вписана снежинка.
Методы:

- thaw() – таять, при этом на каждом шаге пропадают крайние звездочки со всех сторон параметр показывает, сколько шагов
  прошло.
- freeze(n) – намораживаться, при этом сторона квадрата, в который вписана снежинка, увеличивается на 2 * n,
  одновременно добавляются звездочки в нужных местах, чтобы правило соблюдалось.
- thicken() – утолщаться, ко всем линиям звездочек с двух сторон добавляются параллельные (если перед этим снежинка
  таяла, то теперь звездочки восстанавливаются).
- show() – показывать (рисуется снежинка в виде квадратной матрицы со звездочками и дефисами в пустых местах).

# Задача 10. Класс «Robot»

Класс инициализируется начальными координатами – положением Робота на плоскости, обе координаты заключены в пределах
от 0 до 100. Робот может передвигаться на одну клетку вверх (N), вниз (S), вправо (E), влево (W). Выйти за границы
плоскости Робот не может. Метод move() принимает строку – последовательность команд перемещения робота, каждая буква
строки соответствует перемещению на единичный интервал в направлении, указанном буквой. Метод возвращает список
координат – конечное положение Робота после перемещения. Метод path() вызывается без аргументов и возвращает список
координат точек, по которым перемещался Робот при последнем вызове метода move. Если метод не вызывался, возвращает
список с начальным положением Робота.

# Задача 11. Класс «Темы» (Themes)

Экземпляру класса при инициализации передается аргумент – список тем для
разговора. Класс реализует методы:

- add_theme(value) – добавить тему в конец;
- shift_one() – сдвинуть темы на одну вправо (последняя становится первой, остальные сдвигаются);
- reverse_order() – поменять порядок тем на обратный;
- get_themes() – возвращает список тем;
- get_first() – возвращает первую тему.
  Пример 1
  Ввод:
  tl = Themes(['weather', 'rain'])
  tl.add_theme('warm')
  print(tl.get_themes())
  tl.shift_one()
  print(tl.get_first())
  Вывод:
  ('weather', 'rain', 'warm')
  warm
  Пример 2
  Ввод:
  tl = Themes(['sun', 'feeding'])
  tl.add_theme('cool')
  tl.shift_one()
  print(tl.get_first())
  tl.reverse_order()
  print(tl.get_themes())
  Вывод:
  cool
  ('feeding', 'sun', 'cool')

# Задача 12. Класс «ПчёлоСлон» (BeeElephant)

Экземпляр класса инициализируется двумя целыми числами: первое относится к пчеле, второе – к слону. Класс реализует
следующие методы:

- fly() – может летать – возвращает True, если часть пчелы не меньше части слона, иначе False;
- trumpet() – трубить – если часть слона не меньше части пчелы, возвращает строку: “tu-tu-doo-doo!”, иначе “wzzzzz”.
- eat(meal, value) – есть – может есть только нектар (nectar) или траву (grass). Если съедает нектар, то из части слона
  вычитается количество съеденного, пчеле добавляется, иначе наоборот: у пчелы вычитается, а слону добавляется. Не может
  увеличиться выше 100 и уменьшиться меньше 0;
- get_parts() – возвращает список из значений: [часть пчелы, часть слона].
  Пример 1
  Ввод:
  be = BeeElephant(3, 2)
  print(be.fly())
  print(be.trumpet())
  be.eat('grass', 4)
  print(be.get_parts())
  Вывод:
  True
  wzzzzz
  (0, 6)
  Пример 2
  Ввод:
  be = BeeElephant(13, 87)
  print(be.fly())
  print(be.trumpet())
  be.eat('nectar', 90)
  print(be.trumpet())
  print(be.get_parts())
  Вывод:
  False
  tu-tu-doo-doo!
  wzzzzz
  (100, 0)

# Задача 13. Класс «Разговор» (Talking)

Экземпляр класса инициализируется с аргументом name – именем котенка. Класс реализует методы:

- to_answer() – ответить: котенок через один раз отвечает да или нет, начинает с да. Метод возвращает “moore-moore”,
  если да, “meow-meow”, если нет. Одновременно увеличивается количество соответствующих ответов;
- number_yes() – количество ответов да;
- number_no() – количество ответов нет.
  Пример 1
  Ввод:
  tk = Talking('Pussy')
  print(tk.to_answer())
  print(tk.to_answer())
  print(tk.to_answer())
  print(f'{tk.name} says "yes" {tk.number_yes()} times, "no" {tk.number_no()} times')
  Вывод:
  moore-moore
  meow-meow
  moore-moore
  Pussy says "yes" 2 times, "no" 1 times
  Пример 2
  Ввод:
  tk = Talking('Pussy')
  tk1 = Talking('Barsik')
  print(tk.to_answer())
  print(tk1.to_answer())
  print(tk1.to_answer())
  print(tk1.to_answer())
  print(f'{tk.name} says "yes" {tk.number_yes()} times, "no" {tk.number_no()} times')
  print(f'{tk1.name} says "yes" {tk1.number_yes()} times, "no" {tk1.number_no()} times')
  Вывод:
  moore-moore
  moore-moore
  meow-meow
  moore-moore
  Pussy says "yes" 1 times, "no" 0 times
  Barsik says "yes" 2 times, "no" 1 times

# Задача 14. Класс «Воздушный Замок» (AirCastle)

Экземпляр класса инициализируется с аргументами:

- высота;
- количество составляющих облаков;
- цвет.
  Класс должен реализовывать методы:

1. change_height(value) – изменить высоту на value, может уменьшаться только до нуля;
2. сложить с числом, добавляется n облаков к замку, одновременно увеличивается высоту на n // 5;
3. экземпляр класса можно вызвать с аргументом – целым числом, означающим прозрачность облаков; метод возвращает
   значение видимости замка, рассчитанное по формуле: высота // прозрачность * количество облаков;
4. __str__ – возвращает строковое представление в виде: “The AirCastle at an altitude of <высота> meters is <цвет>
   with <количество облаков> clouds”.
5. экземпляры можно сравнивать: сначала по количеству облаков, затем по высоте, затем по цвету по алфавиту; для этого
   нужно реализовать методы сравнения: >, <, >=, <=, ==, !=.

# Задача 15. Класс Добрый Ифрит (GoodIfrit)

Экземпляр класса инициализируется с аргументами: высота, имя, доброта. Класс должен реализовывать функциональность

- change_goodness(value) – менять доброту на указанную величину; не может стать отрицательной, в этом случае становится
  равной 0;
- к экземпляру класса можно прибавить число: (gi1 = gi + number), создается новый экземпляр с высотой, большей на
  величину number, остальные характеристики те же;
- экземпляр класса можно вызвать с аргументом, возвращается значение: аргумент * доброта // высота
- __str__() – возвращает строку вида: “Good Ifrit <имя>, height <высота>, goodness <доброта>”
- экземпляры можно сравнивать между собой: сначала по доброте, затем по высоте, затем по имени по алфавиту; для этого
  нужно реализовать методы сравнения: <, >, <=, >=, ==, !=.
  Ввод:
  gi = GoodIfrit(80, "Hazrul", 3)
  gi.change_goodness(4)
  print(gi)
  gi1 = gi + 15
  print(gi1)
  print(gi(31))
  Вывод:
  Good Ifrit Hazrul, height 80, goodness 7
  Good Ifrit Hazrul, height 95, goodness 7
  Ввод:
  gi = GoodIfrit(80, "Hazrul", 3)
  gi1 = GoodIfrit(80, "Dalziel", 1)
  print(gi < gi1)
  gi1.change_goodness(2)
  print(gi > gi1)
  print(gi, gi1, sep='\n')
  Вывод:
  False
  True
  Good Ifrit Hazrul, height 80, goodness 3
  Good Ifrit Dalziel, height 80, goodness 3

# Задача 16. Класс «Волшебник» (Wizard)

Экземпляр класса при инициализации принимает аргументы:

1. имя;
2. рейтинг;
3. на какой возраст выглядит.
   Класс должен обеспечивать функциональность:
1. change_rating(value) – изменять рейтинг на значение value; не может стать больше 100 и меньше 1, изменяется только до
   достижения экстремального значения; при увеличении рейтинга уменьшается возраст на abs(value) // 10, но только до 18,
   дальше не уменьшается;
2. при уменьшении рейтинга возраст соответственно увеличивается;
3. к экземпляру класса можно прибавить строку: (wd += string), значение рейтинга увеличивается на ее длину, а возраст,
   соответственно, уменьшается на длину // 10, условия изменения такие же;
4. экземпляр класса можно вызвать с аргументом-числом; возвращает значение: (аргумент - возраст) * рейтинг;
5. __str__() – возвращает строку: “Wizard <name> with <rating> rating looks <age> years old”
6. экземпляры класса можно сравнивать: сначала по рейтингу, затем по возрасту, затем по имени по алфавиту; для этого
   нужно реализовать методы сравнения: <, >, <=, >=, ==, !=.

# Задача 17. Класс «Сотрудник компании» Worker

Экземпляр класса при инициализации принимает аргументы:

1. имя, должность и стаж работы сотрудника,
2. метод print_info() выводит информацию о сотруднике в формате: «Имя: Василий Должность: Системный администратор Стаж:
   3 года»
3. При выводе стажа нужно учитывать, что «года» должно заменяться на «лет» или «год» в зависимости от числа.
   worker1 = Worker("Алексей", "Программист", 17)
   worker1.print_info()
   print()
   worker2 = Worker("Анна", "Маркетолог", 2)
   worker2.print_info()
   print()
   worker3 = Worker("Дмитрий", "Аналитик", 1)
   worker3.print_info()
   print()

# Задача 18. Класс Post

Класс описывает публикацию от пользователя в сети:

1. никнейм пользователя,
2. время публикации,
3. количество лайков,
4. текст сообщения,
5. список комментариев.
   Конструктор класса получает автора, устанавливает время, зануляет количество ругательств, а для комментариев создает
   списочный массив. Добавить метод, позволяющий поставить лайк сообщению.

# Задача 19. Классы «Товар» и «Склад»

Класс «Товар»содержит следующие закрытые поля:

1. название товара,
2. название магазина в котором продается товар
3. стоимость товара в рублях
   Класс «Склад» содержит закрытый массив товаров. Обеспечить следующие возможности:
1. вывод информации о товаре по номеру с помощью индекса
2. вывод информации о товаре, название которого введено с клавиатуры
3. сортировку товаров по названию магазина, по наименованию и цене;
4. перегруженную операцию сложения товаров, выполняющую сложение их цен.

# Задача 20. Классы «Клиент»(Client) и «Банк» (Bank)

Класс «Клиент» содержит поля: код клиента, ФИО, дата открытия вклада, размер
вклада, процент по вкладу. Класс «Банк» (class Bank) содержит поле clientBase представляющем собой список клиентов и
методами:

1. addClient(client) — принимает объект клиента и помещает его в base.
2. showByMoney(money) — принимает количество денег и выводит информацию о всех клиентах у которых размер вклада больше
3. showByCode(cod) — принимает код и выводит всю информацию клиенте с данным кодом.
4. showByProc(proc) — принимает процент и выводит информацию о всех клиентах у которых процент по вкладу больше данного.

# Задача 21. Класс «Автомобиль» и дочерний класс «Автобус»

Экземпляр класса имеет координаты своего положения и угол, описывающий направление движения. Он может быть изначально
поставлен в любую точку с любым направлением (конструктор), может проехать в выбранном направлении определённое
расстояние и может повернуть, то есть изменить текущее направление на любое другое. Реализуйте класс автомобиля, а также
класс, который будет описывать автобус. Кроме того, что имеется у автомобиля, у автобуса должны быть поля, содержащие
число пассажиров и количество полученных денег, изначально равные нулю. Также должны быть методы «войти» и «выйти»,
изменяющие число пассажиров. Наконец, метод move должен быть переопределён, чтобы увеличивать количество денег в
соответствии с количеством пассажиров и пройденным расстоянием.

# Задача 22. Классы «ПЕРСОНА», «АБИТУРИЕНТ», «СТУДЕНТ», «ПРЕПОДАВАТЕЛЬ»

Класс ПЕРСОНА, экземпляр класса инициализируется аргументами фамилия, дата рождения и содержит методы, позволяющие
вывести информацию о персоне, а также
определить ее возраст.
Дочерние классы: АБИТУРИЕНТ (фамилия, дата рождения, факультет), СТУДЕНТ (фамилия, дата рождения, факультет, курс),
ПРЕПОДАВАТЕЛЬ (фамилия, дата рождения, факультет, должность, стаж), содержат свои методы вывода информации.
Создайте список из n персон, выведите полную информацию из базы, а также организуйте поиск персон, чей возраст попадает
в заданный диапазон.
